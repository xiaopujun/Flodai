# 自定义节点开发计划：打造“蓝图式”交互体验

基于您的需求（React Flow + Ant Design 6 + Less + MobX），我为您制定了以下分步开发计划。我们将采用 **"Base Node + 具体业务节点"** 的架构模式，确保所有节点风格统一且易于扩展。

## 核心架构设计

### 1. 目录结构规范
我们将新建 `src/components/nodes` 目录，集中管理所有节点逻辑：
```text
src/components/nodes/
├── BaseNode/           # [通用] 节点外壳（处理样式、选中态、通用头部）
├── AINode/             # [业务] AI生成节点（大模型调用、流式输出）
├── FileNode/           # [业务] 文件读写节点（路径选择、内容预览）
└── index.ts            # [注册] 节点类型注册表 (nodeTypes)
```

### 2. 数据流设计 (MobX)
React Flow 的 `data` 属性将作为 MobX Store 的一部分。
- **UI 状态**：输入框内容、下拉选择等直接绑定到 `WorkflowStore`。
- **运行时状态**：AI 的流式输出结果将实时更新到节点 data 中，触发组件重渲染实现“打字机”效果。

---

## 详细开发步骤

### 第一阶段：基础设施 (Base Node)
**目标**：确立 "Light Chaser Pro" 的视觉基调，实现类似于虚幻引擎蓝图的节点外壳。
1.  **创建 `BaseNode` 组件**：
    *   封装通用的 **Header**（支持自定义图标、标题、颜色）。
    *   封装通用的 **Body** 容器。
    *   统一管理 **Handle**（连接点）的样式，确保连接点在左/右侧垂直居中或按需排列。
2.  **样式实现 (`BaseNode.module.less`)**：
    *   实现深色磨砂玻璃背景 (`#1e1e2f`)。
    *   实现选中时的霓虹光晕效果 (`box-shadow` 配合 `--lc-accent-neon`)。
    *   集成 Ant Design 的 Token，确保字体和圆角一致。

### 第二阶段：AI 节点开发 (AI Node)
**目标**：实现核心的 AI 工作流节点，支持流式反馈展示。
1.  **UI 布局**：
    *   **输入区**：Prompt 文本域（支持变量插入提示）、模型选择下拉框 (Antd Select)。
    *   **配置区**：折叠面板，包含温度 (Temperature)、最大Token数等高级设置。
    *   **输出区**：**流式结果预览面板**。这是 MVP 的重点，我们将使用一个只读的文本区域，模拟打字机效果显示 `data.output` 的内容。
2.  **交互逻辑**：
    *   左侧 Handle：接收 `Context` (上下文) 或 `Trigger` (触发信号)。
    *   右侧 Handle：输出 `Result` (生成的内容)。

### 第三阶段：文件节点开发 (File Node)
**目标**：实现本地文件系统的交互能力。
1.  **UI 布局**：
    *   **模式切换**：读取文件 / 写入文件 (Segmented Controller)。
    *   **路径选择**：路径输入框 + "浏览" 按钮 (模拟调用 Tauri Dialog API)。
    *   **格式选择**：Markdown / JSON / Text。
2.  **交互逻辑**：
    *   **写入模式**：左侧接收内容输入，右侧输出成功/失败状态。
    *   **读取模式**：左侧接收触发信号，右侧输出读取到的文件内容。

### 第四阶段：注册与集成
**目标**：让 React Flow 识别并渲染这些新节点。
1.  **注册节点**：在 `src/components/nodes/index.ts` 中建立映射：
    ```typescript
    export const nodeTypes = {
      aiNode: AINode,
      fileNode: FileNode,
    };
    ```
2.  **更新 Store**：在 `WorkflowStore.ts` 中添加初始化数据，将默认节点替换为我们开发的 `aiNode` 和 `fileNode` 实例，以便启动即见效果。

## 验收标准
1.  **视觉**：节点风格符合 "Light Chaser Pro" 规范（深色、霓虹、圆角）。
2.  **交互**：可以拖拽节点，节点内的输入框可以正常输入并更新 Store 数据。
3.  **连接**：节点之间可以创建连线。

---
**您是否同意这个开发计划？** 如果同意，我将从**第一阶段：基础设施 (Base Node)** 开始执行。

## AI Agent 节点功能需求（DeepSeek + Tools + Memory）

本章节用于规划后续要接入的“AI Agent 节点”能力。该节点是一个**完全自驱动的智能中枢**，负责协调大模型、工具和记忆模块，为后续复杂 AI 工作流打基础。

### 1. 节点定位与总体目标
- 作为工作流中的“智能大脑”，接收上游输入，根据配置自动决定：
  - 如何组织 Prompt（系统提示 + 业务输入 + 历史记忆）  
  - 是否、如何调用工具（例如 HTTP 请求、数据库查询等）  
  - 何时结束推理并返回最终结果  
- 不与具体模型/工具实现强耦合，通过抽象层对接具体子模块（DeepSeek、HTTP 等），保证可扩展性。
- 输出**结构化结果**给下游节点（例如字段 `result.text`、`result.meta`），方便被 HTTP 请求、文件节点等消费。

### 2. 角色与子模块划分

AI Agent 由以下几个角色组合而成，每个角色都应有清晰的职责边界：

1. **Agent 主体（AI Agent Node）**
   - 与画布上其他节点对接的唯一入口/出口。  
   - 负责：
     - 接收上游上下文（触发器、文件内容、用户输入等）。  
     - 组装 Prompt（包含系统提示 / 业务输入 / 历史消息 / 工具说明）。  
     - 驱动“Agent 执行循环”（模型调用 + 工具调用 + 记忆更新）。  
     - 将最终结果映射为标准输出字段，交给下游节点。  

2. **模型子模块（Chat Model，例如 DeepSeek Chat Model）**
   - 包装具体大模型（优先支持 DeepSeek），对外暴露统一接口：  
     - 输入：对话消息列表 `messages` + 参数（temperature、maxTokens 等）。  
     - 输出：模型回复（文本内容 + 可能包含“工具调用指令”的结构化数据）。  
   - 承载以下配置：
     - 模型提供方（Provider）：DeepSeek / 其他。  
     - 模型名称（Model Name）：`deepseek-chat` 等。  
     - API Key / Base URL / 代理设置（前端不直接持久化敏感信息，实际调用在后端完成）。  
     - 默认采样参数（temperature、top_p、max_tokens 等）。  

3. **工具子模块（Tools，如 HTTP Request 工具）**
   - 每个工具描述一类可被大模型调用的能力，例如：
     - HTTP 请求（调用第三方 API、内部服务）。  
     - 数据库查询、搜索服务、任务执行等。  
   - 工具需要包含两类信息：
     1. **执行配置**（Execution Config）：  
        - 对 HTTP 工具来说，包含 `URL`、`Method`、`Headers`、`Query`、`Body` 等。  
     2. **给大模型看的“工具描述”**：  
        - 工具名称（例如 `get_latest_news`）。  
        - 功能说明（自然语言描述：工具用途、适用场景）。  
        - 参数 Schema（参数名、类型、是否必填、含义）。  
        - 返回值大致结构的说明（方便模型在调用后理解结果）。  
   - AI Agent 应该能够挂载多个工具，并在执行过程中按需调用其中一个或多个。

4. **记忆子模块（Memory）**
   - 负责管理对话/知识历史，用于增强当前轮推理。  
   - 初期支持：
     - 会话记忆（Conversation Memory）：记录最近 N 轮消息。  
   - 可扩展支持：
     - 知识库记忆（Vector / RAG）：从外部文档召回相关内容拼入 Prompt。  
   - 需要定义：
     - 存储范围（仅当前流程运行 vs. 跨多次运行共享）。  
     - 容量控制策略（比如最多 N 轮、最大 token 数）。  

### 3. 数据流与接口需求

1. **输入数据结构**
   - 上游节点输出通过“输入映射（Input Mapping）”配置映射到 Agent 上下文：  
     - 支持从上游字段中选择作为：  
       - 用户问题（User Message）。  
       - 业务参数（如时间、地区、用户 ID）。  
       - 文件内容或接口结果。  
   - 支持设置静态字段（例如固定的查询关键词、默认任务描述）。

2. **输出数据结构**
   - Agent 执行结束后，生成统一的输出对象，例如：  
     - `result.text`：最终自然语言回答。  
     - `result.toolCalls`：执行过的工具及其参数、结果摘要。  
     - `result.raw`：可选的原始大模型返回（便于调试）。  
   - 通过“输出映射（Output Mapping）”将上述字段暴露给下游节点配置使用。

3. **内部接口抽象**
   - 对模型定义接口（示例）：  
     - `callModel(messages, options) => ModelResponse`。  
   - 对工具定义接口：  
     - `executeTool(name, args) => ToolResult`。  
   - 对记忆定义接口：  
     - `loadMemory(context) => MemoryContext`。  
     - `saveMemory(context, newMessages) => void`。

### 4. 执行流程（Agent Loop）需求

Agent 的核心是“循环决策执行”机制，推荐采用类似 ReAct / Tool Calling 模式。需求如下：

1. **Prompt 组装**
   - 必须支持将以下部分组装为模型输入的 messages：
     - 系统提示（System Prompt）：描述 Agent 角色和行为边界。  
     - 历史对话（来自 Memory）。  
     - 当前轮用户输入（来自 Input Mapping）。  
     - 工具列表说明（每个工具的说明与参数 Schema）。  

2. **循环步骤**
   - 步骤 1：调用 Chat Model，得到回复。  
   - 步骤 2：解析回复类型：  
     - 若为“最终回答”，结束循环。  
     - 若包含“工具调用指令”，进入步骤 3。  
   - 步骤 3：根据指令调用对应工具：  
     - 执行工具逻辑，拿到结果。  
     - 将“工具调用 + 工具结果”作为新的消息追加到 messages。  
   - 步骤 4：根据配置的最大迭代次数/超时时间决定是否继续循环，如未达上限则回到步骤 1。  

3. **停止条件**
   - 至少支持以下停止条件：  
     - 模型明确给出最终答案。  
     - 达到最大步骤数（例如 3~5 步）。  
     - 发生不可恢复错误（例如工具连续失败、后端异常）。  

### 5. 配置与可视化需求

1. **节点主配置（AI Agent Node 面板）**
   - 基本信息：节点名称、描述。  
   - 系统提示配置（System Prompt 编辑区域）。  
   - 输入映射（选择上游字段 -> Prompt 变量）。  
   - 输出映射（Agent 输出字段 -> 下游可见字段）。  
   - 执行参数：最大步骤数、超时时间、是否记录详细日志等。

2. **模型区（Model）**
   - 在 UI 中单独显示一个模型卡片（例如“DeepSeek Chat Model”）：  
     - 可选择模型类型 / 模型名。  
     - 温度、最大 Token 等基础参数。  
   - 与后端集成时，保证前端不直接展示/持久化敏感 Key，只以“已配置模型标识”形式存在。

3. **工具区（Tools）**
   - 以列表/卡片形式展示当前挂载的工具，每个工具可以：  
     - 查看详情（执行配置 + 工具描述）。  
     - 启用/停用。  
   - 支持添加新的工具实例（至少支持 HTTP Request 工具）。  

4. **记忆区（Memory）**
   - 可视化展示：是否开启记忆、记忆模式（仅当前运行 / 跨运行）、窗口大小等。  
   - 可选：提供“清空记忆”操作入口。

5. **画布上的精简展示 vs 详细信息**
   - 精简模式：  
     - 仅展示清晰的 Agent 图标 + 名称 + 少量关键状态（例如是否挂载工具）。  
   - 详细模式 / 浮层：  
     - 展示模型、工具、记忆等配置详情，便于调试和排查。  
   - 要求与现有节点的“精简/详细模式 + 悬浮浮层”交互保持风格一致。

### 6. 错误处理与可观测性需求

- 对模型调用失败、工具执行失败、记忆读写失败等情况进行分类处理：  
  - 记录错误信息（至少包含时间、节点 ID、调用类型、错误描述）。  
  - 提供可读的错误提示字段给下游节点（例如 `result.error`）。  
- Agent 节点输出中应包含基础调试信息：  
  - 是否发生过工具调用。  
  - 使用了哪些工具、调用次数。  
  - 触发的停止条件类型（正常结束 / 步骤数上限 / 错误中断）。  
- 后续可在 UI 中提供“调试模式”，显示更详细的日志和中间过程。

---

本功能需求文档只作为 AI Agent 节点的**设计蓝本**，暂不要求立即实现。在后续需要接入完全自驱动 AI Agent 时，可基于本节内容拆分为具体开发任务。
